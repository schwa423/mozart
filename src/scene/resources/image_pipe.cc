// Copyright 2017 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "apps/mozart/src/scene/resources/image_pipe.h"

#include "apps/mozart/src/scene/fence.h"
#include "apps/mozart/src/scene/resources/gpu_memory.h"
#include "apps/mozart/src/scene/resources/host_memory.h"
#include "apps/mozart/src/scene/session/session.h"

namespace mozart {
namespace scene {

const ResourceTypeInfo ImagePipe::kTypeInfo = {
    ResourceType::kImagePipe | ResourceType::kImageBase, "ImagePipe"};

ImagePipe::ImagePipe(Session* session)
    : ImageBase(session, ImagePipe::kTypeInfo),
      images_(session->error_reporter()) {}

ImagePipe::ImagePipe(Session* session,
                     ::fidl::InterfaceRequest<mozart2::ImagePipe> request)
    : ImageBase(session, ImagePipe::kTypeInfo),
      handler_(std::make_unique<ImagePipeHandler>(std::move(request), this)),
      images_(session->error_reporter()) {}

void ImagePipe::AddImage(uint32_t image_id,
                         mozart2::ImageInfoPtr image_info,
                         mx::vmo vmo,
                         mozart2::MemoryType memory_type,
                         uint64_t memory_offset) {
  vk::Device device = session()->context()->vk_device();
  MemoryPtr memory;
  switch (memory_type) {
    case mozart2::MemoryType::VK_DEVICE_MEMORY:
      memory = GpuMemory::New(session(), device, std::move(vmo),
                              session()->error_reporter());
      break;
    case mozart2::MemoryType::HOST_MEMORY:
      memory = HostMemory::New(session(), device, std::move(vmo),
                               session()->error_reporter());
      break;
  }
  if (!memory) {
    session()->error_reporter()->ERROR()
        << "ImagePipe::AddImage: Unable to create a memory object";
    CloseConnectionAndCleanUp();
    return;
  }
  auto image = CreateImage(session(), memory, image_info, memory_offset,
                           session()->error_reporter());
  if (!images_.AddResource(image_id, image)) {
    // Provide an additional error message to the one generated by
    // AddResource().
    session()->error_reporter()->ERROR() << "ImagePipe::AddImage had an error.";
    CloseConnectionAndCleanUp();
    return;
  }
};

void ImagePipe::CloseConnectionAndCleanUp() {
  handler_.reset();
  is_valid_ = false;
  frames_.clear();
  images_.Clear();

  // Schedule a new frame.
  session()->context()->ScheduleUpdate(0);
}

void ImagePipe::OnConnectionError() {
  CloseConnectionAndCleanUp();
}

ImagePtr ImagePipe::CreateImage(Session* session,
                                MemoryPtr memory,
                                const mozart2::ImageInfoPtr& image_info,
                                uint64_t memory_offset,
                                ErrorReporter* error_reporter) {
  return Image::New(session, memory, image_info, memory_offset, error_reporter);
}

void ImagePipe::RemoveImage(uint32_t image_id) {
  if (!images_.RemoveResource(image_id)) {
    // Provide an additional error message to the one generated by
    // RemoveResource().
    session()->error_reporter()->ERROR()
        << "ImagePipe::RemoveImage had an error.";
    CloseConnectionAndCleanUp();
  }
};

void ImagePipe::PresentImage(uint32_t image_id,
                             mx::event acquire_fence,
                             mx::event release_fence) {
  // Verify that image_id is valid.
  if (!images_.FindResource<Image>(image_id)) {
    // Provide an additional error message to the one generated by
    // FindResource().
    session()->error_reporter()->ERROR()
        << "ImagePipe::PresentImage had an error.";
    CloseConnectionAndCleanUp();
  }

  frames_.push_back(
      Frame{image_id, std::make_unique<AcquireFence>(std::move(acquire_fence)),
            std::move(release_fence)});

  // TODO: capture only a weak ptr?
  frames_.back().acquire_fence->WaitReadyAsync(
      [session = session()] { session->context()->ScheduleUpdate(0); });
};

const escher::ImagePtr& ImagePipe::GetEscherImage() {
  // TODO: What should the behavior here be? If a particular frame was not
  // signalled, but subsequent ones were, then should we skip it? For now, we
  // follow a strict queue order and wait for frames to be acquired before
  // we advance. This behavior will become more sophisticated once we add
  // presentation times.

  // TODO: Don't let the number of frames grow beyond a certain number.
  while (frames_.size() > 1) {
    const Frame& second_frame = frames_[1];
    if (second_frame.acquire_fence->is_ready()) {
      // Pop the first frame since we are no longer rendering it. We hand off
      // its release fence to the |ReleaseFenceSignaller|, which will signal it
      // as soon as all work previously submitted to the GPU is finished.
      session()->context()->release_fence_signaller()->AddCPUReleaseFence(
          std::move(frames_.front().release_fence));
      frames_.pop_front();
    } else {
      break;
    }
  }

  // Return the first frame if we have one that's ready (i.e. had its acquire
  // fence signalled).
  if (frames_.size() > 0 && frames_.front().acquire_fence->is_ready()) {
    ImagePtr image = images_.FindResource<Image>(frames_.front().image_id);
    FTL_DCHECK(image);
    return image->GetEscherImage();
  }

  static const escher::ImagePtr kNullEscherImage;
  return kNullEscherImage;
};

}  // namespace scene
}  // namespace mozart
