// Copyright 2017 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This is a simple client application that demonstrates the use of the
// Shadertoy API (see shadertoy.fidl).

#include "application/lib/app/application_context.h"
#include "application/lib/app/connect.h"
#include "lib/ftl/command_line.h"
#include "lib/ftl/log_settings_command_line.h"
#include "lib/ftl/logging.h"
#include "lib/mtl/tasks/message_loop.h"

#include "apps/mozart/examples/shadertoy/services/shadertoy.fidl.h"
#include "apps/mozart/examples/shadertoy/services/shadertoy_factory.fidl.h"
#include "apps/mozart/lib/scene/client/resources.h"
#include "apps/mozart/lib/scene/client/session.h"
#include "apps/mozart/lib/scene/session_helpers.h"
#include "apps/mozart/lib/scene/types.h"

using namespace mozart;
using namespace mozart::client;

static constexpr uint32_t kScreenWidth = 2160;
static constexpr uint32_t kScreenHeight = 1440;

class ShadertoyClientApp {
 public:
  ShadertoyClientApp()
      : application_context_(app::ApplicationContext::CreateFromStartupInfo()),
        loop_(mtl::MessageLoop::GetCurrent()),
        scene_manager_(
            application_context_
                ->ConnectToEnvironmentService<mozart2::SceneManager>()),
        session_(scene_manager_.get()),
        // TODO: we don't need to keep this around once we have used it to
        // create a Shadertoy.  What is the best way to achieve this?
        shadertoy_factory_(
            application_context_
                ->ConnectToEnvironmentService<ShadertoyFactory>()) {
    scene_manager_.set_connection_error_handler([this] {
      FTL_LOG(INFO) << "Lost connection to SceneManager.";
      loop_->QuitNow();
    });
    session_.set_connection_error_handler([this] {
      FTL_LOG(INFO) << "Lost connection to Session.";
      loop_->QuitNow();
    });
  }

  void Init() {
    // Create an ImagePipe and pass one end of it to the ShadertoyFactory in
    // order to obtain a Shadertoy.
    fidl::InterfaceHandle<mozart2::ImagePipe> image_pipe_handle;
    auto image_pipe_request = image_pipe_handle.NewRequest();
    shadertoy_factory_->TakeImagePipe(shadertoy_.NewRequest(),
                                      std::move(image_pipe_handle));
    shadertoy_.set_connection_error_handler([this] {
      FTL_LOG(INFO) << "Lost connection to Shadertoy.";
      loop_->QuitNow();
    });

    // Pass the other end of the ImagePipe to the Session, and wrap the
    // resulting resource in a Material.
    ResourceId image_pipe_id = session_.AllocResourceId();
    session_.Enqueue(
        NewCreateImagePipeOp(image_pipe_id, std::move(image_pipe_request)));
    Material material(&session_);
    material.SetTexture(image_pipe_id);
    session_.Enqueue(NewReleaseResourceOp(image_pipe_id));

    // Create a RoundedRectangle that will display the texture generated by
    // the Shadertoy.
    rect_ = std::make_unique<ShapeNode>(&session_);
    rect_->SetShape(RoundedRectangle(&session_, 640, 480, 80, 80, 80, 80));
    rect_->SetMaterial(material);

    // Create a Scene containing the rounded rect.
    Scene scene(&session_);
    scene.AddChild(rect_->id());

    // Create a DisplayRenderer that renders the Scene from the viewpoint of a
    // Camera.
    renderer_ = std::make_unique<DisplayRenderer>(&session_);
    renderer_->SetCamera(Camera(scene));

    // Wait kSessionDuration seconds, and close the session.
    constexpr int kSessionDuration = 40;
    loop_->task_runner()->PostDelayedTask(
        [this] { loop_->QuitNow(); },
        ftl::TimeDelta::FromSeconds(kSessionDuration));

    start_time_ = mx_time_get(MX_CLOCK_MONOTONIC);
    Update(start_time_);
  }

  void Update(uint64_t next_presentation_time) {
    // Translate the rounded rect.
    double secs =
        static_cast<double>(next_presentation_time - start_time_) / kBillion;

    constexpr float kCenterX = kScreenWidth * 0.5f;
    constexpr float kCenterY = kScreenHeight * 0.5f;

    rect_->SetTranslation(kCenterX + sin(secs * 0.8) * 500.f,
                          kCenterY + sin(secs * 0.6) * 570.f, 10.f);

    // Present
    session_.Present(
        next_presentation_time, [this](mozart2::PresentationInfoPtr info) {
          Update(info->presentation_time + info->presentation_interval);
        });
  }

 private:
  static constexpr uint64_t kBillion = 1000000000;

  std::unique_ptr<app::ApplicationContext> application_context_;
  mtl::MessageLoop* loop_;
  mozart2::SceneManagerPtr scene_manager_;
  mozart::client::Session session_;
  ShadertoyFactoryPtr shadertoy_factory_;
  ShadertoyPtr shadertoy_;

  std::unique_ptr<mozart::client::ShapeNode> rect_;
  std::unique_ptr<mozart::client::DisplayRenderer> renderer_;

  uint64_t start_time_ = 0;
};

int main(int argc, const char** argv) {
  auto command_line = ftl::CommandLineFromArgcArgv(argc, argv);
  if (!ftl::SetLogSettingsFromCommandLine(command_line))
    return 1;

  mtl::MessageLoop loop;
  ShadertoyClientApp app;
  loop.task_runner()->PostTask([&app] { app.Init(); });
  loop.Run();
  return 0;
}
